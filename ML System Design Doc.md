# Interior Design 2.0

## Секция 1.1 Цель разработки.  
  Магазины мебели желают демонстрировать потенциальному покупателю примеры того, как могут выглядеть полностью меблированные комнаты. Обычно такие фотографии собраны в каталоги. Покупателю удобно иметь возможность просмотра нескольких наиболее релевантных его запросу изображений комнат вместо просмотра огромного каталога.  
  Без использования машинного обучения, возможно бы было создать поиск по описаниям фотографий, например основанный на реккурентных выражениях. Проблема такого подхода заключается в том, что если не будет найдено точное совпадение слов, клиент в ответ на запрос не получит никакое изображение. В случае же ML-решения клиент получит в ответ фотографию, описание которой наиболее соответствует его запросу, даже если в итоге некоторые детали не соответствуют действительности, или соответствующие предметы заданы синонимами.   
  Успехом выполнения задачи будет является работающий веб-сайт в котором пользователь может ввести запрос  на английском языке в свободной форме с описанием представляемого ему интерьера интересующей его комнаты, и получить в ответ несколько наиболее релевантных ему картинок из каталога магазина  

 
## Секция 1.2 Бизнес-требования и ограничения.
Проект представляет собой реализацию системы текстового поиска по каталогу изображений меблированных комнат. Для его реализации необходимо предоставление каталога изображений меблированных комнат. Также необходимо проведение командой проекта разметки данных. 
Ограничением является поиск только по заранее загруженным в систему данным.

Требования к системе:  
1. Пользователь должен иметь возможность ввести описание интерьера на английском языке в свободной форме.
2. Пользователь длжен иметь возмодность выбрать нужный ему тип комнаты из следующих:  спальня, кухня, гостиная, обеденная зона, ванная комната.
3. Пользователь должен иметь возможность получить фотографию комнаты интерьера по типу соответствующей его запросу .
4. От момента отправки запроса в систему до получения картинки должно пройти не более 10 секунд.
5. Интерфейс системы должен содержать окно ввода текста и кнопку подтверждения в центральной части экрана, чтобы быть хорошо видимым интуитивно понятным пользователю. 
6. Доступ к интерфейсу системы должен осуществляться с помощью url адреса в сети интернет.

## 1.3 Критерии успеха проекта.  
Проект считается выполненным если:
- выбрана модель для сравнения описания фотографий комнат с запросом пользователя;
- выбрана метрика для сравнения ml-моделей;
- cоздан фронтенд и бекенд сайта соответствующие требованиям к системе;
- время отклика системы не больше 10 с при нагрузке 1 RPM

## 1.4 Use-case использования.  
Пользователь выбирает из пяти предложенных типов комнат нужную ему, а также вводит на английском языке описание в свободной форме интересующей его комнаты. Система возвращает ему фотографию трех комнат из каталога магазина.  

## 2.1. Постановка задачи машинного обучения.  
### 2.1.1 Задача машинного обучения.  
Задачей машинного обучения является нахождения близости вектора-эмбединга запроса клиента  с векторами-эмбеднгами, описывающими фотографии из каталога.  
Метрикой машинного обучения является близость векторов, которая вычисляется как среднее арифмеметическое косинусного расстояния и меры Жакара.    
## 2.2. Диаграмма решения задачи
![Диаграмма ML решения задачи](https://github.com/AnnaLeites/InteriorDesign/blob/main/diagramML.png)
## 2.3 Данные.
Мы работаем с пятью видами комнат: спальня, гостинная, обеденная зона, кухня, ванная комната.   
От заказчика получаем каталог фотографий меблированных комнат. Далее, инженеры по работе с данными из нашей команды создают текстовую разметку каталога в формате  .txt по следующему правилам:   
1) Каждая строка описывает только одну фотографию  
2) В начале строки пишется название файла изображения с указанием формата  
3) Далее, пишется тип комнаты  
4) Далее, указываются предметы внутреннего оформления комнаты и мебели по возможности с указанием их характеристик.  
5) Названия файла, тип комнаты и последующее описания отдельных предметов внутри разделяются точкой с запятой.  
6) Каждый тип комнат описывается в отдельном .txt файле.  
7) Всё описание производится на английском языке.

Итого, получаем пять файлов в соответствии с пятью видами комнат.  
Ввиду того, что проект служит демонстрацией возможностей системы потенциальным клиентам, фотографии каталога были взяты из открытых источников в интернете, и не предполагается коммерческое использование проекта при выполнении программы на непосредственно этих картинках.  

## 2.4 Бейзлайн.  
Бейзлайном данного решения является веб-сайт на котором пользователь может ввести тип комнаты (на английском языке): спальня, гостиная, обеденная зона, кухня, ванная.  
В ответ он получает случайную комнату заданного типа.  
![Диаграмма бейзлайн решения задачи](https://github.com/AnnaLeites/InteriorDesign/blob/main/baseline_diagram.png)  

## 2.5.  Выбор модели для итогового решения.   
Мы сравнили 5 моделей создания эмбеддингов на подготовленных нами данных и тестах.   
### 2.5.1 Сравниваемые модели.
1. В качестве первой из рассматриваемых моделей мы выбрали word2vec обученную на google news данных. Её размер  составляет около 1,6 гб.  
2. В качестве следующей из моделей мы подумали использовать word2vec от gensim обученную только на наших данных, таким образом получалась 3. маленькая модель. Однако, эта модель имела существенный недостаток, препятствующий задуманному функционированию программы: она не может превращать в вектора слова, которые не были в исходном довольно ограниченном наборе данных.  
3. Далее, мы рассматривали модель tok2vec “en_core_web_lg” из библиотеки spacy, которя обучена на текстах блогов, новостей и комментариев, и весит около 600 мб.  
4. Мы попробовали также трансформерную модель all-MiniLM-L6-v2. Она удобна в использовании из-за того, что ей можно передать целый список строк для кодирования без итераций в цикле. Её вес составляет 80 мб.  
5. Последней моделью, которую мы исследовали, была tok2vec “en_core_web_md” из библиотеки spacy, которая весит 40 мб.   


### 2.5.2 Входные данные для тестирования моделей
В качестве тестов используется следующий подготовленный командой набор из 10 пар: вид комнаты, запрос пользователя:
1. "bedroom", "Large bedroom with double wood bed, two windows, dressing table, and picture.",
2. "bedroom", "Medium-sized bedroom with light red double bed, TV stand, glass doors, and white ceiling fan.",
3. "bedroom", "Small bedroom with black double bed, two wall lamps, and dark curtains.",
4. "bedroom", "A cozy bedroom with a beige double bed, TV, pouf, and spacious wardrobe",
5. "bedroom", "I want a big room",
6. "bathroom", "Medium bathroom, black washbasin, mirror, shelf, white bathtub, glass door, and brown blinds",
7. "dining", "Show me a medium-sized dining area with a round glass table, six white chairs, white blinds, and beige curtains",
8. "dining", "I want to see a medium-sized dining room with a grey table, seven grey chairs, two black chandeliers, a grey flowerpot, and a white sofa",
9. "kitchen", "Show me a medium-sized kitchen with white cabinets, a sink, a black ceiling fan, a metallic hob, a white and black refrigerator, and a brown rug",
10. "living room", "I want to see a large living room with a beige sofa, two beige armchairs, a beige pouf, a black coffee table, a black end table, a grey rug, two black wall lamps, and two paintings"

### 2.5.3 Метод сравнения моделей. 
В каждой из сравниваемых моделей мы использовали для вычисления косинусное расстояние, также в моделях 1,2,3 и 5 мы использовали вышеуказанную метрику близости векторов.  Однако, ввиду того, что абсолютное значение косинусного расстояние между векторами в разных векторных пространствах не всегда информативно отражает качество моделей эмбеденингов, а также того, что в работающей системе важна производительность и размер итоговой модели, мы выбрали модель, учитывая в первую очередь её размер, поэтому победила модель номер 5 - “en_core_web_md” из библиотеки spacy.

## 3.1 Архитектура решения
Мы рассмотрели два архитектурных варианта, замерели производительность и выбрали наиболее быстродействующее решение. 
Выбранный вариант представлен на первой диаграмме.

![FastAPI](https://github.com/AnnaLeites/InteriorDesign/blob/main/ArchD.png)  
Отклонённый из-за быстродействия вариант показан на следующей диаграмме. 
![Node.js](https://github.com/AnnaLeites/InteriorDesign/blob/main/ArchD2.png)  

## 3.2 Разворачивание сервиса.
В случае сервера на python запуск выполняется командой
Uvicorn main:app  
В случае если сервер состоит из фронтенда написанного на React, запускаемого с помощью команды 
npm start ;  
А также из бекенда, запускаемого, командой node server.js   


## 3.3 Требования к работе сервиса. 
Для успешного запуска сервиса необходимы библиотеки
spacy  
numpy  
nltk
fastapi
spacy
numpy
python-multipart
Uvicorn
Сервис будет успешно выполняться на машине с 8 гб оперативной памяти, языковая модель оптимизирована на запуск без графического процессора. Программа занимает до 900 мб места.   

## 3.4 Нагрузочное тестирование.  
Ввиду локального запуска сервиса на данный момент его максимальная пропусканая способность - один пользователь.  
Мы сравнивали по быстродействие две архитектуры:React+Node.js который вызывает python код исполнения. При такой архитектуре полное время обработки запроса составляет около 25 секунд при том, что запрос от фронтенда к бекенду передаётся за секунду. Основая часть тормозящая систему - это каждый раз новая загрузка модели при новом вызове python кода, а также не векторизированность некоторых функций.  

## 3.5 Масштабирование системы.   
Мы планируем cоединить фронтенд на react с бекендом на node.js и на fastapi. Разместить приложение можно будет на хостинге типа netlify. Таким образом, у нас получиться одновременный доступ большого количества пользователей. Бутылочным горлышком - основным ограничением на количество пользователей одновременно является быстродействие нашей модели включая препроцессинг. Возможным решением может быть запуск нескольких инстансов python-fastapi- сервера например в контейнерах и распределение между ними нагрузки с помощью node.js сервера.   



